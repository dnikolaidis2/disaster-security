# Assignment 3 - ΗΡΥ414
Dimitrios Nikolaidis

AM 2015030100

For this assignment we finished the implementation of a small tool for encryption/decryption of files using the RSA algorithm.
The tool is named assign_3 and was implemented from scratch using c.

## Examples

make && ./assign_3 -h

./assign_3 -g

./assign_3 -i hpy414_encryptme_pub.txt -o TUC2015030100_encrypted_pub.txt -k hpy414_public.key -e

./assign_3 -i hpy414_decryptme_pub.txt -o TUC2015030100_decrypted_pub.txt -k hpy414_public.key -d

./assign_3 -i hpy414_encryptme_priv.txt -o TUC2015030100_encrypted_priv.txt -k hpy414_private.key -e

./assign_3 -i hpy414_decryptme_priv.txt -o TUC2015030100_decrypted_priv.txt -k hpy414_private.key -d


## Assign_3 Tool
This tool supports the following cryptographics functions encryption, decryption and key generation.
These were implemented in the following functions.

1. void rsa_keygen(void)
    This function generates two rsa keys and saves them in private.key and public.key files respectively.
    The keys are generated by first selecting two random prime numbers p, q calculated using the sieve_of_eratosthenes.
    Then their product n is calculated and also fi_n as (p-1)*(q-1). Then e and d are calculated using choose_e and mod_inverse(e, fi_n)
    respectively. Finally n and d are saved as the public key and n and e as the private key.

2. void rsa_encrypt(char *input_file, char *output_file, char *key_file)
    This function reads the contents of input_file file and encrypts them using the key found in key_file.
    The resulting ciphertext is saved in output_file file. This function encrypts the contents of the file
    by raising each byte of input_file to the power of d and calculating the mod with n (d and n read from key file).
    To perform the above calculation the function mod_exp() is used.
   

3. void rsa_decrypt(char *input_file, char *output_file, char *key_file)
    This function reads the contents of input_file file and decrypts them using the key found in key_file.
    The resulting plain text is saved in output_file file. This function decrypts the contents of the file
    by raising each size_t value in the file input_file to the power of e and calculating the mod with n (e and n read from key file).
    To perform the above calculation the function mod_exp() is used.

## Helper functions
A number of helper functions were also implemented to help with the implementation of the above main functions.

1. size_t * sieve_of_eratosthenes(int limit, int *primes_sz)
    This function implements the sieve of eratosthenes algorithm for calculating all primes between 1 and limit.
    It returns an array of size primes_sz and the size using the argument primes_sz. This function goes through
    all primes and calculates all their composites. All remaining numbers are primes.

2. int gcd(int a, int b)
    Calculate greatest common denominators of a and b using Euclid's algorithm, a simple recursive algorithm.

3. size_t choose_e(size_t fi_n)
    This function calculates and returns e based on fi_n in a very dumb way by simply going through all numbers
    between fi_n - 1 to 2 and checking if gcd(i, fi_n) == 1 and returns it.


4. size_t mod_inverse(size_t a, size_t b)
    This function calculates the inverse mod of a and b by the naive method of checking for every number from
    1 to b and returns it.


5. size_t mod_exp(size_t base, size_t exp, size_t mod)
    This function calculates the following mathematical expression base ^ exp % mod. It does this by instead of
    raising base to the power of exp directly doing exp number of multiplications step by step.