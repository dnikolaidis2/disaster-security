# Assignment 2 - ΗΡΥ414
_Dimitrios Nikolaidis_

_AM 2015030100_

For this assignment we finished the implementation of a small tool for encryption/decryption of files as well as signing and verifying them. The tool is named assign_1 was implemented with openssl as a backend for the cryptographic functions.

## Task F.4
Neither of the files hpy414_verifyme_256.txt and hpy414_verifyme_128.txt can be verified using the tool as decrscibed in this exercise.

## Examples
```
make && ./assign_1 -h

./assign_1 -i encryptme_256.txt -o decryptme_256.txt -b 256 -p TUC2015030100 -e

./assign_1 -i hpy414_decryptme_128.txt -o hpy414_encryptme_128.txt -b 128 -p hpy414 -d

./assign_1 -i signme_128.txt -o verifyme_128.txt -b 128 -p TUC2015030100 -s

./assign_1 -i hpy414_verifyme_256.txt -o hpy414_signme_256.txt -b 256 -p hpy414 -v
Could verify file!

./assign_1 -i hpy414_verifyme_128.txt -o hpy414_signme_128.txt -b 128 -p hpy414 -v
Could verify file!
```

## Assign_1 Tool
The tool consists of the following parts.

1. __void keygen(unsigned char *password, unsigned char *key, unsigned char *iv, int bit_mode)__

    This function generates a *key* and *iv* based on a *password* using the *bit_mode* to select the appropriate cipher for which they are going to be used. This function uses EVP_BytesToKey() function to generate the key which uses the EVP_sha1() hashing algorithm.

2. __int encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, unsigned char *iv, unsigned char *ciphertext, int bit_mode)__
   This function encrypts a string called *plaintext* using the *key* and *iv* generated by keygen() and returns the ciphertext as output. This function uses the *bit_mode* to select between aes-128-ecb and aes-256-ecb. The size of the encrypted output is also returned by said function. For the encryption implementation the EVP API is used by using the EVP_EncryptXXX() functions.

3. __int decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key, unsigned char *iv, unsigned char *plaintext, int bit_mode)__
   This function decrypts the *ciphertext* using *key* and *iv* and returns the decrypted *plaintext*. This function uses the *bit_mode* to select between aes-128-ecb and aes-256-ecb. The size of the decrypted output is also returned by said function. For the decryption implementation the EVP API is used by using the EVP_DecryptXX() functions.

4. __void gen_cmac(unsigned char *data, size_t data_len, unsigned char *key, unsigned char *cmac, int bit_mode)__
    This function generates a CMAC for given *data* of *data_len* using the *key*. The resulting cmac is returned through *cmac* and *bit_mode* is used to select between aes-128-ecb and aes-256-ecb. This function is implemented using the CMAC API provided by openssl and more specifically the CMAC_XX() functions. The output CMAC length is alway equal to 16.

5. __int verify_cmac(unsigned char *cmac1, unsigned char *cmac2)__
    This function performs a simple byte by byte compare of *cmac1* and *cmac2* and returns 1 if they are equal and 0 otherwise.

6. __main__
    The main logic of the tool is implemented in main using the above functions to perform according to the exercise parameters. The tool either encrypts, decrypts, signs or verifies and exits. Use the `-h` parameter to get extra help for the use of the tool.

### Notes
To calculate the size of memory to allocate for the result of the encryption function the following formula was used: 
```
CipherText = PlainText + BLOCK_SIZE - (PlainText MOD BLOCK_SIZE)
```
